// DragonSoul Web — Phase 3.5 preloaded game assets
// Extracted from DragonSoul-Fixed2.apk
// These are served synchronously to WebFiles.internal() calls

(function(root) {
    if (!root.GAME_ASSETS) root.GAME_ASSETS = {};
    const A = root.GAME_ASSETS;

    A["shaders/Decals-fs.glsl"] = "#ifdef GL_ES\n\t#define LOWP lowp\n\tprecision mediump float;\n#else\n\t#define LOWP \n#endif\n\nvarying LOWP vec4 v_color;\nvarying vec2 v_texCoords;\nuniform sampler2D u_texture;\n\n#ifdef HSV\n// H - an offset in degrees of the color spectrum\n// S - 1 for no change in saturation, > 1 to saturate, < 1 to desaturate\n// V - 1 for no change, > 1 brightens, < 1 darkens\nuniform vec3 u_HSV;\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n#endif\n\n#ifdef DARKEN\nuniform float u_darkenAlpha;\n#endif\n\n#ifdef ALPHA_ATLAS\nvarying vec2 v_alphaCoords;\nuniform float u_alphaAtlasDisable;\n#endif\n\n#ifdef RENDER_TYPE\nuniform float u_renderType;\n#endif\n\n#ifdef ALPHA_TEST\nuniform float u_alphaTest;\n#endif\n\nvoid main()\n{\n\t#ifdef ALPHA_ATLAS\n\t\tLOWP vec4 texVal;\n\t\tif(u_alphaAtlasDisable >= 1.0) {\n\t\t\ttexVal = texture2D(u_texture, v_alphaCoords);\n\t\t} else {\n\t\t\ttexVal = texture2D(u_texture, v_texCoords);\n\t\t\ttexVal.a = texture2D(u_texture, v_alphaCoords).r;\n\t\t}\n\t#else\n\t\tLOWP vec4 texVal = texture2D(u_texture, v_texCoords);\n\t#endif\n\t\n\tgl_FragColor = v_color * texVal;\n\t\n\t#ifdef ALPHA_TEST\n\t\tif(gl_FragColor.a < u_alphaTest)\n\t\t\tdiscard;\n\t#endif\n\t\n\t#ifdef DARKEN\n\t\tgl_FragColor.r *= u_darkenAlpha;\n\t\tgl_FragColor.g *= u_darkenAlpha;\n\t\tgl_FragColor.b *= u_darkenAlpha;\n\t\t// Samsung tab and kindle fire devices have a bug with their graphics chipset that throws off alpha value - DS-1967\n\t\tgl_FragColor.a = v_color.a * texVal.a;\n\t#endif\n\t\n\t#ifdef HSV\n\t\t// Most of the HSV code is from http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n\t\tvec3 fragRGB = gl_FragColor.rgb;\n\t\tvec3 fragHSV = rgb2hsv(fragRGB);\n\t\tfragHSV.x += u_HSV.x / 360.0;\n\t\tfragHSV.yz *= u_HSV.yz;\n    \t//fragHSV.xyz = mod(fragHSV.xyz, 1.0);\t// Modding saturation and value doesn't make sense, just going to do hue \n    \tfragHSV.x = mod(fragHSV.x, 1.0);\n    \tfragRGB = hsv2rgb(fragHSV);\n\t\tgl_FragColor.rgb = fragRGB;\n\t#endif\n\t\n\t#ifdef DESATURATE\n\t\tgl_FragColor.r = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\n\t\tgl_FragColor.g = gl_FragColor.b = gl_FragColor.r;\n\t#endif\n\t\n\t#ifdef RENDER_TYPE\n\t\tif(u_renderType >= 2.0) { // brighten\n\t\t\tgl_FragColor.r += .23;\n\t\t\tgl_FragColor.g += .23;\n\t\t\tgl_FragColor.b += .23;\n\t\t}\n\t\telse if(u_renderType >= 1.0) {\t// desaturate\n\t\t\tgl_FragColor.r = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\n\t\t\tgl_FragColor.g = gl_FragColor.b = gl_FragColor.r;\n\t\t}\n\t#endif\n}\n";

    A["shaders/Decals-vs.glsl"] = "attribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec2 a_texCoord0;\n\nuniform mat4 u_projTrans;\n\n#ifdef PARALLAX\nuniform float u_zoom;\t// (0,1) makes this layer appear closer, > 1 makes the layer appear further away\n#endif\n\nvarying vec4 v_color;\nvarying vec2 v_texCoords;\n\n#ifdef ALPHA_ATLAS\nvarying vec2 v_alphaCoords;\n#endif\n\nvoid main()\n{\n\tv_color = a_color;\n\t\n\tgl_Position =  u_projTrans * a_position;\n\t\n\t#ifdef PARALLAX\n\t\tgl_Position.x *= u_zoom;\n\t\tgl_Position.y *= u_zoom;\n\t#endif\n\t\n\t#ifdef ALPHA_ATLAS\n\t\tv_alphaCoords = a_texCoord0;\n\t\tv_texCoords = v_alphaCoords + vec2(0.0, 0.5);\n\t#else\n\t\tv_texCoords = a_texCoord0;\n\t#endif\n}";

    A["shaders/distancefield-fs.glsl"] = "#ifdef GL_ES\n#define LOWP lowp\nprecision mediump float;\n#else\n#define LOWP\n#endif\n\nuniform sampler2D u_texture;\nuniform float u_lower;\nuniform float u_upper;\n\nvarying LOWP vec4 v_color;\nvarying vec2 v_texCoord;\n\nvoid main() {\n  float distance = texture2D(u_texture, v_texCoord).a;\n\tfloat alpha = smoothstep(u_lower, u_upper, distance);\n\tgl_FragColor = vec4(v_color.rgb, alpha * v_color.a);\n}";

    A["shaders/distancefield-vs.glsl"] = "uniform mat4 u_projTrans;\n\nattribute vec4 a_position;\nattribute vec2 a_texCoord0;\nattribute vec4 a_color;\n\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\n\nvoid main() {\n\tgl_Position = u_projTrans * a_position;\n\tv_texCoord = a_texCoord0;\n\tv_color = a_color;\n}";

    A["shaders/distancefield_dropshadow-fs.glsl"] = "#ifdef GL_ES\n#define LOWP lowp\nprecision mediump float;\n#else\n#define LOWP\n#endif\n\nuniform sampler2D u_texture;\nuniform float u_lower;\nuniform float u_upper;\nuniform float u_outlineShadowLower;\nuniform float u_y_shadow_offset;\n\nvarying LOWP vec4 v_color;\nvarying vec2 v_texCoord;\n\nconst vec4 SHADOW_COLOR = vec4(0,0,0,1);\n\nvoid main() {\n\tfloat distance = texture2D(u_texture, v_texCoord).a;\n\tfloat alpha = smoothstep(u_lower, u_upper, distance);\n\tvec4 baseColor = vec4(v_color.rgb, alpha);\n\t\n\t// Sample outline\n\tfloat outlineAlpha = smoothstep(u_outlineShadowLower, u_lower, distance);\n\tvec4 outlineC = SHADOW_COLOR * outlineAlpha;\n\t\n\t// Drop shadow\n    vec2 SHADOW_OFFSET = vec2(0,-u_y_shadow_offset);\n\tfloat shadowDist = texture2D(u_texture, v_texCoord.xy + SHADOW_OFFSET.xy).a;\n\tvec4 shadowC = SHADOW_COLOR * smoothstep(u_outlineShadowLower, u_lower, shadowDist);\n\t\n\tvec4 outlineShadow = mix(shadowC, outlineC, outlineAlpha);\n\t\n\tgl_FragColor = mix(outlineShadow, baseColor, alpha);\n\tgl_FragColor.a *= v_color.a;\n}";

    A["shaders/distancefield_outline-fs.glsl"] = "#ifdef GL_ES\n#define LOWP lowp\nprecision mediump float;\n#else\n#define LOWP\n#endif\n\nuniform sampler2D u_texture;\nuniform float u_lower;\nuniform float u_upper;\n\n// Outer transition\nuniform float u_outlineMinVal0;\nuniform float u_outlineMinVal1;\n\n// Inner transition\nuniform float u_outlineMaxVal0;\nuniform float u_outlineMaxVal1;\n\nconst vec4 OUTLINE_COLOR = vec4(0,0,0,1);\n\nvarying LOWP vec4 v_color;\nvarying vec2 v_texCoord;\n\nvoid main() {\n  float distance = texture2D(u_texture, v_texCoord).a;\n\tfloat alpha = smoothstep(u_lower, u_upper, distance);\n\tvec4 baseColor = vec4(v_color.rgb, alpha);\n\t\n\tif(distance >= u_outlineMinVal0 && distance <= u_outlineMaxVal1) {\n\t\tfloat oFactor = 1.0;\n\t\tif(distance <= u_outlineMinVal1) {\n\t\t\toFactor = smoothstep(u_outlineMinVal0, u_outlineMinVal1, distance);\n\t\t} else {\n\t\t\toFactor = smoothstep(u_outlineMaxVal1, u_outlineMaxVal0, distance);\n\t\t}\n\n\t\tbaseColor = mix(baseColor, OUTLINE_COLOR, oFactor);\n\t}\n\n\tgl_FragColor = baseColor;\n\tgl_FragColor.a *= v_color.a;\n}";

    A["shaders/iris-fs.glsl"] = "#ifdef GL_ES\n\t#define LOWP lowp\n\tprecision mediump float;\n#else\n\t#define LOWP \n#endif\n\nuniform float u_fadeLength;\t// fade length in screen coords\nuniform float u_fadeStart;\t// start of fade in screen units from the center of the screen\nuniform vec2 center;\t// center of iris\n\nvoid main()\n{\n\tfloat dist = distance(center, vec2(gl_FragCoord.x, gl_FragCoord.y)) - u_fadeStart;\n\tgl_FragColor = mix(vec4(0,0,0,0), vec4(0,0,0,1), dist / u_fadeLength);\n}";

    A["shaders/iris-vs.glsl"] = "attribute vec4 a_position;\n\nuniform mat4 u_projTrans;\n\nvoid main()\n{\t\n\tgl_Position =  u_projTrans * a_position;\n}";

    console.log("[Assets] 8 shaders préchargés");
})(typeof self !== "undefined" ? self : this);